# Задача A1
Даны два рекурсивных алгоритма обработки целочисленного массива A размера n:
```cpp
algorithm1(A, n)
    if n ≤ 20
        return A[n]
    x = algorithm1(A, n – 5)
    for i = 1 to ⌊n/2⌋
        for j = 1 to ⌊n/2⌋
            A[i] = A[i] – A[j]
    x = x + algorithm1(A, n – 8)
    return x
```
```cpp
algorithm2(A, n)
    if n ≤ 50
        return A[n]
    x = algorithm2(A, ⌊n/4⌋)
    for i = 1 to ⌊n/3⌋
        A[i] = A[n – i] – A[i]
    x = x + algorithm2(A, ⌊n/4⌋)
    return x
```
1. Для каждого из представленных алгоритмов составить рекуррентное соотношение, которое выражает их временную сложность T(n). Обратите внимание, что рекуррентное соотношение должно давать полное представление о сложности алгоритма, т.е., охватывать как рекурсивную, так и нерекурсивную ветку вычислений. Предполагается, что все арифметические операции выполняются за постоянное время.
2. Вычислите асимптотическую точную границу θ(f(n)) временной сложности для каждого из представленных алгоритмов, если это возможно. В случае невозможности формирования асимптотической точной границы, представить отдельно верхнюю и нижнюю границы. Обоснуйте свой ответ с помощью метода подстановки, дерева рекурсии, или индукции.

# Решения
### Задание 1
##### Алгоритм 1
Рекуррентное соотношение для времени выполнения первого алгоритма может быть записано как: 
`T(n) = O(1)`, если n ≤ 20; 
`T(n) = T(n – 5) + T(n – 8) + O((n/2)^2)`, если n > 20.
Рекурсивные вызовы уменьшают размер входных данных на 5 и 8, а вложенные циклы выполняются `(n/2)^2` раз. Можно упростить запись, заметив что `O((n/2)^2) ~ O(n)`.
##### Алгоритм 2
Рекуррентное соотношение для времени выполнения второго алгоритма может быть записано как:
`T(n) = O(1)`, если n ≤ 50;
`T(n) = 2*T(n/4) + O(n/3)`, если n > 50.
Алгоритм 2 также вызывается рекурсивно дважды, но теперь с массивом, уменьшенным в четыре раза, и проводит операции в одном цикле за время `O(n/3) ~ O(n)`.

### Задание 2
##### Алгоритм 1
Это плохой алгоритм, здесь сразу 2 рекурсивных вызова, поэтому `θ(f(n))` мы не посчитаем, но можем разбить это на части:
Для вычисления `O(f(n))` положим `T(n-8) ~ T(n-5)`, так как первое очевидно выполняется быстрее. Тогда `T(n) = 2T(n – 5) + O(n^2)`. 
Дерево рекурсии имеет следующий вид:
На каждом уровне рекурсии, у нас есть столько же задач, сколько и на предыдущем уровне (так как каждую задачу мы разбиваем на две), среди которых, каждая задача обрабатывается за время `O(n^2)`. Кроме того, количество уровней рекурсии равно `n/5` (так как на каждом уровне размер задачи уменьшается на `5`).
Итак, время работы для каждого уровня составляет `O(n^2)`. Поскольку у нас есть `n/5` уровней, общее время работы будет равно `(n/5)*O(n^2) = O(n^3/5) ~ O(n^3)`.
Аналогично рассуждая для нижней границы, положим `T(n-5) ~ T(n-8)`, и увидим что `Ω(f(n)) = Ω(n^3/8) ~ Ω(n^3)`.
Таким образом `θ(f(n)) = θ(n^3)`.
##### Алгоритм 2
Итак, `T(n) = 2*T(n/4) + O(n)`. Тогда по мастер-теореме `a = 2`, `b = 4`, `c = 1`. Видим, что `1 > log4(2)`, следовательно `θ(f(n)) = θ(n)`.

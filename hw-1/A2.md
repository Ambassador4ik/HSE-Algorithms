# Задача A2
Дана итерационная реализация алгоритма возведения некоторого положительного числа x в степень n, где операция mod соответствует вычислению остатка, а операция div – целочисленному делению:

```cpp
fastExponent(x, n):
r = 1
p = x
e = n
while e > 0
    if e mod 2 <> 0
        r = r * p
    p = p * p
    e = e div 2
```

1. Какое точное количество операций умножения требуется выполнить, чтобы вычислить x^n с помощью алгоритма FAST EXPONENT? Всегда ли данный алгоритм лучше наивного способа вычисления, требующего в точности n умножений?
2. Сформулировать условие P, которое подходит в качестве инварианта цикла while. Представить достаточное обоснование выбора инварианта. Выполнить проверку выполнения найденного инварианта  до входа в цикл (INIT), в каждой итерации цикла (CONT), а также при выходе из цикла (EXIT).

# Решения
Мои рассуждения здесь не учитывают операцию сравнения, а так же вычисления div/mod. Беда небольшая - если очень хочется их учесть, добавим по `log2(n)` к итоговой сумме для каждой операции (ну и предварительно умножив `log2(n)` на константу, отвечающую весу конкретной операции, если вдруг нам не хочется считать их элементарными). В условии же просили именно это, вроде как.. не бейте палками (опционально).
### Задание 1
Пусть число `n` представлено в двоичной форме. Тогда цикл будет работать следующим образом: выполнить `2` операции, если число оканчивается на единицу (сначала `r *= p`, потом `p *= p`), и выполнить `1` операцию, если число оканчивается на ноль (только `p *= p`). Таким образом, на выполнение алгоритма нам потребуется `2*c1 + c0`, где `c1` - количество единиц в двоичной записи числа `n`, а `c0` - количество нулей. Математически это можно записать в виде `f(n) = ...` но я этого делать не буду, потому что формула эта очень нехорошая для компьютера и требует вычисления бесконечных сумм. Но нам ее считать и не нужно. На самом деле, в худшем случае нам придется выполнить всего `2(⌊log2(n)⌋ + 1)` операций (это для степеней вида `2^n - 1`).\
Теперь для ответа на второй вопрос достаточно решить неравенство `2(⌊log2(n)⌋ + 1) > n`. Исследуя функции, можем заметить, что для степени `3` 'наивный' способ работает лучше - `FAST EXPONENT` возведет в куб за 4 операции - 2 раза мы войдем в условный оператор, а значит 2*2 = 4 раза выполним умножение. 'Наивный' же способ справится за 3 операции.

### Задание 2
`P = 'x^n = r * p^e'`\
В целом довольно очевидный инвариант - в `r` мы 'накапливаем' разложение `x` по степеням двойки, начиная с самой маленькой. В `p^e` остается недосчитанная часть - умножаем её на часть разложения, которую уже посчитали, и получаем искомое `x^n`. 

`INIT P`: При изначальных `r = 1; p = x; e = n;` равенство бесспорно верно.\
`CONT P`: Пусть на некоторой итерации цикла `x^n = r * p^e`. Тогда на следующей итерации может произойти следующее: `{r -> r; p -> p * p; e -> e / 2}` либо `{r -> r * p, p -> p * p; e -> e / 2}.` В первом случае понятно что `r * p^e = r * (p^2)^(e / 2)`. Во втором же случае мы 'потеряем' `p` при округлении вниз нечетного `e` и тут же восстановим эту потерю за счет умножения `r -> r * p`. Так или иначе, `P` остается верным предикатом.\
`EXIT P`: После выполнения цикла `e = 0` => `p^e = 1`, а `x^n = r`, как и ожидалось - `r` и есть искомая экспонента, а предикат остается верным.

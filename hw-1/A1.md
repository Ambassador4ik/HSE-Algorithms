# Задача A1
Дана следующая итерационная реализация алгоритма сортировки выбором заданного целочисленного массива A, количество элементов в котором обозначено n:


```c++
selectionSort(A):
for i = 0 to n - 1
    minId = i
    for j = i + 1 to n
        if A[j] < A[minId]
            minId = j
    swap(A[minId], A[i])
```

1. Сформулировать условие P1, которое подходит в качестве инварианта внутреннего цикла алгоритма по j. Представить краткое обоснование (например, с использованием частичной трассировки выполнения цикла).
2. Сформулировать условие P2, которое подходит в качестве инварианта внешнего цикла алгоритма по i. Представить краткое обоснование.
3. Выполнить проверку выполнения найденных инвариантов P1 и P2 до входа в каждый из циклов (INIT), в каждой итерации циклов (CONT), при выходе из цикла (EXIT).

# Решения
В трассировке показаны состояния переменных после завершения итерации.
### Задание 1
`P1 = 'Любой элемент из A[i..j-1] больше либо равен A[minId]'`

```cpp
A = [4, 3, 7, 2]; i = 0; minId = 0;

j = 1:  minId = 1; A[minId] = 3; A[i..j-1] = [4]
j = 2:  minId = 1; A[minId] = 3; A[i..j-1] = [4, 3]
j = 3:  minId = 3; A[minId] = 2; A[i..j-1] = [4, 3, 7]        
```

### Задание 2
`P2 = 'A[0..i] - отсортированный массив'`

```cpp
A = [4, 3, 7, 2];

i = 0:  A[0..i] = [2];
i = 1:  A[0..i] = [2, 3];
i = 2:  A[0..i] = [2, 3, 4];
```

### Задание 3
##### Предикат P1 
`INIT P1`: Конструкция `A[i..j-1]` упрощается до `A[i]`, при этом `A[minId]` либо самый минимальный элемент в срезе (который по сути создается внешним циклом), тогда для него всегда верен этот предикат, либо `A[minId]` - первый элемент массива, он может быть не минимальным только при `i = 0`, тогда `P1 ~ A[0] >= A[0]`, что очевидно верно.\
`CONT P1`: После каждой итерации `A[minId]` - минимальный элемент в срезе, поэтому для него этот предикат верен.\
`EXIT P1`: При выходе из цикла уже обязательно найден минимальный элемент в срезе, а значит предикат верен.

##### Предикат P2
`INIT P2`: При `i = 0` срез `A[0..i]` вырождается в `A[0]`, один элемент всегда отсортирован.\
`CONT P2`: Пусть при `i = p` срез `A[0..i]` был отсортирован. Тогда при `i = p + 1` мы добавим в конец некоторое число `x`, которое не меньше любого числа из этого среза (потому что до этого мы добавляли в срез только такие числа, находя их внутренним циклом). Получим отсортированный срез `A[0..i+1]`, а значит предикат верен.\
`EXIT P2`: После окончания цикла весь массив `A ~ A[0..i]` будет отсортирован.
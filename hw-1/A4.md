# Задача A4
Даны три алгоритма, в рамках которых выполняется обработка целочисленного массива А, содержащего n элементов, а sort(A) соответствует сортировке массива некоторым способом:

```cpp
algorithm1(A)
    c = 0
    ind = -1
    for i = 0 to n
        c1 = 0
        for j = 0 to n
            if A[i] = A[j]
                c1 = c1 + 1
        if c1 > c
            c = c1
            ind = i
    if c > n / 2
        return A[ind]
```
```cpp
algorithm2(A)
    c = 1
    ind = 0
    for i = 1 to n
        if A[ind] = A[i]
            c = c + 1
        else
            c = c - 1
        if c = 0
            ind = i
            c = 1
    return A[ind]
```
```cpp
algorithm3(A)
    if n = 1
        return A[0]
    c = 1
    sort(A)
    for i = 1 to n
        if A[i - 1] = A[i]
            c = c + 1
        else
        if c > n / 2
            return A[i - 1]
        c = 1
```
1. Утверждается, что представленные алгоритмы должны решать одну и ту же задачу, т.е. выдавать один и тот же ответ на одинаковых входных данных.
Согласны ли вы с этим утверждением? Результаты работы каких алгоритмов из представленных могут отличаться? Какую задачу решает каждый алгоритм?
Приведите примеры входных данных, при которых результаты работы алгоритмов могут отличаться, а также совпадать. Поясните свой ответ с помощью трассировки (частичной) работы алгоритмов.
2. Вычислите асимптотическую верхнюю границу O(f(n)) временной сложности для каждого алгоритма. Обоснуйте свой ответ. Представлять полный расчет точного выражения функции временной сложности T(n) не нужно.
3. Какие алгоритмы и каким образом необходимо доработать, чтобы в результате все представленные алгоритмы решали одну и ту же задачу? В ответе представьте инструкции, которые необходимо добавить или удалить.
4.  Докажите, что представленные вами доработки не ухудшают ранее вычисленные в п.2 верхние границы временной сложности. Представьте расчеты верхних границ сложности доработанных алгоритмов.

# Решения

### Задание 1
Все алгоритмы решают одну и ту же задачу - ищут элемент, который встречается в массиве чаще, чем в `n / 2` ячеек. Однако можно заметить, что второй алгоритм может выдавать неверный ответ при отсутствии искомого элемента в массиве, в то время как 1 и 3 вернут none/null/nullptr etc. Чтобы убедиться в этом, можно не делать трассировку - достаточно заметить, что в 1 и 3 алгоритме перед return стоит условие, которое проверяет, действительно ли счетчик набрал более чем `n / 2` подсчетов. Во втором же алгоритме нет ни счетчика, ни проверки - он всегда вернет некоторый элемент.

### Задание 2
**Algorithm1**: Этот алгоритм имеет два вложенных цикла, каждый из которых проходит по всему массиву. Его временная сложность составляет O(n^2).\
**Algorithm2**: Этот алгоритм имеет один цикл, который проходит по всему массиву. Его временная сложность составляет O(n).\
**Algorithm3**: Этот алгоритм сначала сортирует массив, что обычно требует не менее O(n log n) времени, а затем проходит по всему массиву за время O(n). Таким образом, общая временная сложность составляет O(n log n).

### Задание 3
Чтобы второй алгоритм мог работать как остальные, можно добавить проверку найденного элемента: пройдемся по массиву и посчитаем, сколько раз встречается найденный элемент. Теперь сравним результат с `n / 2` и вернем none/null/nullptr если результат отрицательный.

### Задание 4
Предложенная правка не меняет сложность второго алгоритма, поскольку проход по массиву выполняется за линейное время, как и сам алгоритм.